프론트엔드(리액트) + 백엔드(스프링부트) + DB(H2)로 합쳐봤다.

요청(조회, 수정, 삭제, 추가)

비동기로 요청(Axios)

매번 백엔드로 요청하면 코드가 길어지고 중복되는 부분이 많다.
도메인이 변경됐을 때 사용하는쪽에서 전부 다 변경해야하는 문제점이 있다.

api-config.js -> 도메인 설정

apiService.js -> call 함수를 만들어서 axios요청을 대신한다.

확장이나 유지보수에 대한 가능성을 생각해야한다.
추상화, 모듈화를 시켜놓는게 좋다.

url에 따라서 controller가 실행된다.

어떻게 url

스프링부트는 결국 스프링을 기반으로 만들어진 프레임워크이다.
스프링에서는 기본적인 설정들을 어느정도 해줬어야 했다.

web.xml : 스프링의 설정과 관련된 코드들이 있는 파일
스프링부트는 웬만한 설정들은 내부에 다 되어있다.

HandlerMapping : 요청 url연결 -> 어떤 컨트롤러의 메서드가 이 요청을 처리할 것인가를 결정하는 것

HandlerAdapter : Mapping에서 골라준 메서드를 실행하고 결과를 받아오는 객체

------

토큰 기반 인증

사용자가 로그인에 성공하여 인증이 되면 서버측에서 토큰을 발급해준다.

권한이 필요한 서비스에 클라이언트가 요청을 할 때마다 토큰을 같이 전달함으로써 권한이 있는지 확인한다.

통신은 1회성이다.
요청과 응답을 한 번 주고받으면 통신이 끝난다.
로그인을 한 상태를 기억하고 있지 않다.
별수없이 권한이 필요할 때마다 아이디와 비밀번호를 보내야한다.

세션(session)
로그인을하면 서버측에서 세션 객체를 만들어서 저장을 해놓는다.
세션객체는 시간을 정해놓거나, 로그아웃을 하기전까지 유지된다.
브라우저 하나당 1세션이다.
그렇기 때문에 탭을 껏다 켜도 로그인은 유지된다.

권한이 필요한 서비스로 접근할 때 세션 객체가 있다면 로그인되어있다고 간주한다.

단점
사용자가 많아지면 서버에 부담이 간다.
유휴세션을 주기적으로 정리해줘야 한다.
RESTful설계 위배
HTTP의 기본인 무상태(stateless)특성을 훼손한다.

JSON웹 토큰(JWT, JSON Web Token)
JSON형식으로 사용자 정보를 저장하고 서명을 통해 토큰의 무결성을 검증하는 토큰 기반 인증방식

JWT
헤더
- 토큰의 타입 : JWT
- 해싱알고리즘 : HS256

페이로드
- 사용자 id
- 토큰 발행 주체
- 토큰의 만료시간
- 토큰 발행시간

서명
헤더+페이로드를 base64로 인코딩 후 개인키와 함계 선택한 알고리즘으로 해싱한 값값

해싱함수
임의의 길이 데이터가 들어와도 고정길이의 데이터로 만들어주는 함수
SHA-256 해싱함수는 무조건 256비트로 바꾼다(32바이트)

위변조 검증
JWT : 헤더.페이로드.서명

1. 헤더와 페이로드는 base64를 디코딩하여 JSON문자열로 바꾼다(암호화되어있지 않음)
2. 위 문자열은 서명 연산 시 사용된 원본과 동일해야한다.
3. 서명은 개인키를 통해서 비교한다.
- 서명을 통해 무결성과 진위 검증을 한다.

테이블을 생성하고 엔티티와 매핑을 시킨게 아니라 ENTITY를 통해서 JPA가 테이블 생성을 해줬다.
user-entity라는 이름으로 테이블이 생성된다.

의존성주입
1. 필드주입 (@Autowired)
2. setter주입
3. 생성자주입 *가장 많이쓴다.

회원가입, 로그인 기능을 만들었다.

1. 로그인을 구현했으나 다른 API들(Todo에대한 추가, 조회, 삭제, 수정)은 유저가 로그인했는지 모른다.
   내가 만든 REST API기능은 무상태(stateless)이므로 로그인 상태를 기억하지 않는다.

2. 지금까지 작성한 API에서는 로그인 여부 자체를 확인을 안하고 있다.
- 임시 유저 아이디만 제공을 하고 있다.
- 따라서 현재 로그인 기능이 있어도, 어떤 유저가 로그인하던간에 같은 TodoList를 보게된다.

스프링 시큐리티 통합
유저와 관련된 클래스들은 로그인 여부를 저장하지 않는다는점에서 불완전한 상태이다.
스프링 시큐리티와 JWT를 이용해서 해결해보자.

로그인 유지 구현
모든 요청 API에 토큰을 보낸다.
각 API들은 토큰을 확인하고 접근 허용 또는 거부하는 코드를 실행한다.
문제는 모든 API가 이 작업을 해야한다는것이다.
createTodo, getTodo, updateTodo, deleteTodo 4개의 API가 존재하는데,
만약 50개가 넘는 API를 관리한다고 생각하면 50번이나 같은 코드를 작성해야 한다는 문제가 있다.

스프링 시큐리티를 이용해 코드를 한번만 작성하고, 이 코드가 모든 API를 수행하기 바로 전에 실행되도록 구현해보자

JWT 생성 및 반환을 구현
- 유저 정보를 바탕으로 헤더와 페이로드를 작성하고 전자 서명을 한 후, 토큰을 반환할 것이다.
- 구현을 위해 JWT관련 라이브러리를 gradle의존성에 추가할 것이다.

create()메서드는 JWT라이브러리를 이용해 JWT토큰을 생성한다.
토큰을 생성하는 과정에서 우리가 임의로 지정한 SECRET_KEY를 개인키로 사용한다.
validateAndGetUserID()는 토큰을 디코딩, 파싱 및 위조여부를 확인한다.
이후에 우리가 원하는 유저의 ID를 반환한다.
라이브러리 덕분에 JSON을 생성, 서명, 인코딩, 디코딩, 파싱하는 작업을 직접하지 않아도 된다.
TokenProvider를 작성했으니, 로그인을 하면 create()메서드를 통해 토큰을 생성하고

스프링 시큐리티
스프링기반 어플리케이션에서 인증(Authentication)과 인가(Authorization)를 처리하기 위한 보안 프레임워크이다.
스프링 어플리케이션에서 보안과 관련된 다양한 요구 사항을 손쉽게 구현할 수 있도록 돕는다.

주요개념
1. 인증
- 사용자가 누구인지 확인하는 과정
- 사용자가 어플리케이션에 접근할 때 제공한 자격증명을 확인하여 신원을 검증하는 단계

2. 인가
- 인증된 사용자에게 어떤 리소스에 접근할 수 있는지 결정하는 과정
- 사용자에게 주어진 역할(Role)과 권한(Authority)에 따라 리소스에 대한 접근 권한을 부여한다.

3. 필터 기반 아키텍처
- 스프링 시큐리티는 필터 체인 기반으로 동작한다.
- HTTP요청이 들어오면 여러 보안 필터들이 순차적으로 실행되어 요청을 처리하고, 보안 관련 로직을 적용한다.

스프링 시큐리티와 서블릿 필터
- API가 실행될 때마다 기능이 실행되기 전 사용자 인증을 해야한다.
- 필터가 HTTP요청과 응답을 가로채, 요청이 컨트롤러에 도달하기 전 또는 응답이 클라이언트에게 전달되기 전 필요한 전처리나 후처리를 수행하는데 사용된다.
- 주로 보안, 로그기록(로깅), 인코딩 설정, 데이터 압축등의 작업을 처리할 때 유용하다.
- 서블릿 필터릴 구련하고 서블릿 필터를 서블릿 컨테이너가 실행하도록 설정만 하면 된다.




















