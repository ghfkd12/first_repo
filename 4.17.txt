## 4. 17.(Thu) 2일차

## JS

- 배열(Array)
- 비어있는 배열 만드는 법

```jsx
let arr = new Array(3);
arr[0]
arr[1]
arr[2]
arr[3] // 없는 인덱스를 사용하면 방을 늘린다.

// 자바스크립트 배열은 타입의 제약이 없고, 서로 다른 타입을 섞어도 무방하다.
let arr = [10, '안녕', 3.14, true, null, undefined,
{name:'Alice', age:30}, function{console.log('hi'), () => console.log('arrow'), [10,20]];

let student = [{name:'홍길',age:30},{name:'밥',age:50}]

student[0] -> 객체
student[0].name -> '홍길'

let fArr = [function(){console.log('일반함수')}
```

| undefined | null |
| --- | --- |
| 초기화되지 않음 | 의도적으로 비어있다고 명시 |
| js가 자동으로 할당 | 개발자가 의도적으로 표시 |
- 자바 클래스 → 객체
- js에서는 클래스 없이 객체를 직접 만들 수 있다.
- 자바에서는 클래스를 먼저 만든다.
- 필드
- js에서는 key - value로 구성된 프로퍼티의 집합
- 프로퍼티의 value로 함수가 올수도 있는데, 이러한 함수를 메서드라고 한다.
    1. new Object() 생성자 사용하기
        - js의 내장 생성자인 Object를 호출해 빈 객체를 만든 뒤 프로퍼티를 추가하는 방식
    2. 생성자 함수(Constructor Function)
        
        ```jsx
        function User(name, age){
              this.name = name;
              this.age = age;
        }
        ```
        
- 함수 : 자주 사용하는 코드를 하나로 모아서 언제든 호출해서 사용할 수 있도록 만들어 놓은 것

```jsx
function 함수명(매개변수){
      기능
      
      return 반환값
}
```

- 배열을 매개변수로 받는 경우
    
    ```jsx
    function sum(arr){
          let total = 0;
          for(const num of arr){
                total += num;
          }
          return total;
    }
    
    const nums = [1,2,3,4,5];
    console.log(sum(nums));
    ```
    
- React → 페이지 하나를 두고 요소만 바꿔 끼우는 형태
    - SPA(single Page Application) ↔ MPA(Multi Page Application)
- 브라우저가 화면을 렌더링 하는 방식
- 서버에 요청을 하고 화면을 돌려받는다.
- 브라우저는 DOM트리를 만들고, CSSOM트리를 만든다.
- 두개를 합쳐서 RENDER트리를 만들고 RENDER트리를 기반으로 브라우저에 요소들을 배치한다.
- 렌더링 방식
    - 클라이언트 사이드 렌더링(CSR)
        - 클라이언트 쪽에서 HTML, JS를 받아서 브라우저쪽에서 렌더링
        - 초기 로딩속도가 느림
        - 초기 로딩 후, 필요한 데이터만 서버에서 가져와 동적으로 업데이트 하기 때문에 추가 페이지 로딩이 없다.
        - 전체 페이지를 매번 새로 렌더링하지 않고, 변화가 있는 부분만 업데이트하므로 서버의 부담을 덜어준다.
    - 서버 사이드 렌더링(SSR)
        - 웹 페이지를 렌더링 시켜서 클라이언트에게 보낸다.
        - 초기 로딩이 빠르다.
        - 서버에 대한 부하가 커질 수 있다.

### 리액트란?

- 페이스북에서 만든 자바스크립트 라이브러리
- SPA나 모바일 어플리케이션의 개발 토대로 사용이 된다.
- 컴포넌트 기반의 구조(특징)
    - UI를 구성하는 독립적인 단위
    - HTML의 특정부분을 정의할 수 있다.
    - 버튼, 입력 필드, 다이얼로와 같은 다양한 UI요소를 컴포넌트로 만들 수 있다.
- 재사용성
    - 컴포넌트는 재사용이 가능하다.
    - 같은 코드를 여러번 쓰지 않아도 된다.
- 독립성
    - 컴포넌트는 독립적으로 동작할 수 있다.
    - 어플리케이션의 복잡한 UI를 작은 조각으로 나눠서 관리할 수 있다.
- 모든 컴포넌트는 함수로 관리한다.
- 컴포넌트명은 첫글자를 대문자로 쓴다.
- JSX(JavaScript XML) : 자바스크립트 안에 HTML처럼 UI구조를 작성할 수 있게 해주는 문법
- 표현식의 삽입 : 중괄호 {}안에 임의의 JS 표현식을 넣어 결과를 렌더링 할 수 있다.
- 
    
    ```jsx
    const name = '홍길동';
    const element = <h1>안녕, {name}님</h1>
    
    {isLoggedIn ? <Dashboard /> : <LoginForm />}
    
    {item.length> - && <ItemList items={items}/>}
    ```
    
- 앞의 조건이 참이면 컴포넌트를 렌더링 한다.
- 거짓이면 안한다.
- Hook : 리액트에서 제공하는 메서드
    - 리액트 초반 함수형 컴포넌트는 단순한 UI그리기만 가능하고 상태에 대한 관리를 할 수 없었다.
    - 훅의 역할 : 상태 관리와 사이드 이펙트 로직을 함수 단위로 재사용할 수 있게 하고, 클래스 없이도 복잡한 로직을 끔하게 작성하도록 돕는다.
- 상태(state) : 컴포넌트 내부에서 변경 가능한 데이터
- state가 바뀌면 해당 컴포넌트가 다시 렌더링되어 화면에 변경된 내용을 반영한다.
- state를 생성하는 법
    - useState()라는 훅을 사용해야 한다.
- useState()훅이 실행되면 state하나와 state의 값을 변경할 수 있는 setter함수가 요소로 되어있는 배열을 반환한다.
- 리액트는 변수를 이렇게 만든다.
- 초기값 자리에 기본자료형, 배열, 객체도 된다.

```jsx
const [상태변수, setter함수] = useState(초기값);
```

왜 useState()가 제공하는 setter함수를 실행했을 때 자동으로 화면이 렌더링 되는가

1. setter함수를 호출하면 상태가 바뀌었다는 사실을 React에 알린다.
이 컴포넌트를 재 렌더링해야한다고 예약한다

예약된 업데이트 시점에 React는 해당 커포넌트를 다시 호출해 JSX를 살펴본다.

이전 렌더 때와달리 바뀐값을 반환하므로 JSX의 결과가 달라질 수 있다.

setter가 호출되면 바뀐부분만 렌더링 된다라 생각하면 편하다.

Props
컴포넌트에 데이터를 전달하는 방식
외부로부터 값을 받아서 렌더링 하거나 동작할 수 있다.
props라는 이름의 자바스크립트 객체이다.

리액트에서 매개변수 -> props
리액트에서 생명주기를 관리하는 변수 -> state

생명주기 : 언제 메모리에 올라가서 언제 없어지는가를 의미한다.


