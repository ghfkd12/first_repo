디자인 패턴
소프트웨어 설계 과정에서 반복적으로 발생하는 문제를 해결하기 위한 재사용 가능한 설계 기법이다.

특정 언어나 플랫폼에 종속되는것이 아니라, 상황과 해법의 구조를 문서화한 유연한 설계도라고 생각하면 된다.

싱글톤 패턴
스프링이 직접 관리하도록 시킨 클래스는 메모리에 무조건 한번만 올라간다.

사용할 때는 메모리에 올라가 있는 객체를 받아서 사용한다.

팩토리 패턴
객체 생성 로직을 별도의 클래스로 분리하여, 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 만드는 패턴

롬복(lombok)
어노테이션 기반의 코드 생성 라이브러리이다.
자바 클래스에서 반복생성되는코드(getter, setter, 생성자, toString)를 자동으로 생성해준다.
컴파일 시점에 어노테이션이 코드를 주입하므로, 실제 소스파일에는 메서드 구현이 보이지 않는다.

주요 어노테이션 및 역할
@Getter / @Setter : 필드별 getter/setter 메서드 생성
@ToString : toString()메서드 자동생성
@EqualsAndHashCode : equals() & hashCode() 메서드 생성
@NoArgsConstructor : 파라미터 없는 생성자 생성
@AllArgsConstructor : 모든 필드를 파라미터로 받는 생성자 생성
@RequiredArgsConstructor : final 또는 @Nonnull 필드만 파라미터로 받는 생성자 생성
@Builder : 빌더 패턴을 지원하는 빌드 클래스를 생성

의존성 주입(Dependency Injection)
객체가 필요한 의존관계를 외부에서 주입해주는 설계 원칙
'제어역전(Inversion of Control)'의 한 구현 방식으로, 객체 내부가 아니라 외부 컨테이너가 객체의 생명주기와 관계를 관리한다.

필드주입(Field Injection)
클래스의 필드에 @Autowired를 붙여, 스프링이 직접 주입해주는 방식
setter나 생성자 없이도 간단히 주입할 수 있다는 특징이 있다.

장점 : 필드 선언부에 어노테이션만 붙이면 되므로, 다른 코드가 거의 필요없다.
단점 : 불투명성 - 코드만 보고는 어떤의존성이 언제 주입되는지 파악하기 어렵다.
      불변성 미보장 - 초기화 전 필드가 null일 수 있다.

간단히 프로토타입을 빠르게 만들어볼 때 임시로 활용해볼 수 있다.

생성자 주입(Constructor Injection)
객체 생성시점에 필요한 모든 의존성을 생성자의 매개변수로 받아 설정하는 방식

장점 :
불변성 보장 - final필드를 사용할 수 있어, 의존성이 반드시 주입된 상태로 객체가 생성된다.
           - 순환 참조 탐지
           - 순환 의존성이 있을 때 애플리케이션 시작 시점에 바로 예외가 발생해 문제를 조기에 파악할 수 있다.

단점 : 의존성이 많아지면 생성자 매개변수가 길어져 가족성이 떨어질 수 있다.

세터주입(Setter Injection)
setter 메서드를 통해 의존성을 주입하는 방식

장점 : 
의존성이 반드시 필요하지 않은경우, 세터를통해 유연하게 주입여부를 제어할 수 있다.

Gradle
자바, 코틀린, 그루비(groovy) 등 다양한 프로그래밍언어를 지원하는 빌드 자동화 도구이다.

빌드자동화도구 : 
소스코드로부터 실행가능한 산출물을 생성하는 일련의 과정을 관리, 수행해주는 도구
컴파일, 테스트, 패키징, 배포 등 개발 과정의 반복과정을 스크립트나 설정파일로 정의해
사람의 수작업 없이 실행할 수 있게 해준다.

Gradle의 주요특징
1. 의존성 관리
Maven Central, JCenter, Ivy 같은 의존성 저장소에서 외부 라이브러리를 쉽게 가져와
사용할 수 있도록 해준다.
이를 통해 개발자는 필요한 라이브러리를 직접 다운로드하지않고,
빌드 시 자동으로 라이브러리를 다운로드하고 관리할 수 있다.

2. DSL(Domain-Specific Language)
스크립트를 작성할 때 groovy나 코틀린을 사용한다.
빌드 로직을 간결하고 유연하게 작성할 수 있다.

3. 멀티프로젝트빌드
Gradle은 여러 프로젝트를 하나로 묶어 멀티 프로젝트 빌드를 지원한다.

포스트맨 API 테스트툴
REST API는 크게 나워 URI, HTTP메서드, 요청 매개변수 또는 요청 바디로 구분이 되는데,
이를 브라우저에서 테스트하는것에는 한계가 있다.

테스트를 한다고 임시로 프론트엔드 UI를 만드는것은 지속가능한 방법이 아니다.

사용이 간편하고 직관적인 GUI를 제공하는 포스트맨이라는 프로그램을 사용한다.

백엔드 서비스 아키텍처

레이어드 아키텍처 패턴
어플리케이션을 구성하는 요소들을 수평으로 나눠 관리하는 것이다.

표현계층
사용자의 요청을 받고 응답으로 변환하는 계층
비즈니스계층
서비스의 백엔드 기능들이 들어있는 계층(로직)
영속계층
데이터베이스와 맞닿아있는 계층 트랜잭션을 관리한다.
데이터베이스계층
DBMS를 의미한다.

보통 자바의 클래스 종류
기능을 수행하는 클래스, 데이터를 담기 위한 클래스
기능을 하는 클래스 : Controller, Service, Persistance
데이터를 담는 클래스 : 모델, 엔티티

model은 데이터를 담는 역할과 db의 테이블과 스키마를 표현하는 두가지 역할을 한다.

DTO(Data Transition Object)
클라이언트가 데이터를 가지고 요청하거나, 서비스가 요청을 처리하고
클라이언트로 반화환할 때, 모델(entity)자체를 그래도 반환하는 경우는 거의 없다.
보통은 데이터를 전달하기 위해 사용하는 객체인 DTO로 변환해 반환한다.

DTO로 변환해서 반환하는 이유
1. 비즈니스 로직의 캡슐화
- 외부인이 DB스키마를 아는것을 원하지 않는다.
- 이때 DTO처럼 다른 객체로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, DB구조 등을 숨길 수 있다.

2. 클라이언트가 필요한 정보를 모델이 전부 포함하지 않을 수 있다.
- 에러메세지를 보내야할 때
- 어디에 담아서 보내야 하는가?
- 모델은 서비스 로직과는 관련이 없기 때문에 모델에 담는건 적합하지 않다.
- 이런경우 DTO에 실어서 보내는것이 좋다.

REST API
REST(Representatinal State Transfer)아키텍처를 기반으로하는 
API(Application Programming Interface)다.

REST API는 클라이언트와 서버간의 상호작용을 HTTP를 사용해 설계한 웹 서비스 인터페이스로,
데이터를 쉽게 주고받을 수 있게 해준다.

REST API는 웹 어플리케이션, 모바일 앱 등 다양한 시스템간의 통신을 위한 표준으로 널리 사용되고 있다.

이 가이드를 따르는 API를 RESTful API라고 한다.

주요개념
클라이언트 - 서버
리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소스를 소비하기 위해 네트워크를 통해 서버에 접근하는 구조이다.

Stateless
클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미한다.

일관적인 인터페이스
시스템 또는 어플리케이션의 리소스에 접근하기 위한 인터페이스가 일관적이여야 한다.

HTTP메서드 사용의 일관성

GET           /users            모든 사용자 목록 조회
GET           /users/{id}       특정 사용자를 조회
POST          /users            새로운 사용자 생성
PUT           /users/{id}       사용자 정보 업데이트
DELETE        /users/{id}       사용자 삭제

API사용자들이 다양한 리소스와 상호작용할 때 동일한 패턴을 예상할 수 있다.

URI구조의 일관성
URI경로를 일관되게 설계하는것도 중요하다.
리소스의 이름은 복수형으로 일관되게 사용하고, 리소스간 관계를 표현할 때도 규칙적으로 작성해야 한다.

GET /users/{userId}/posts
Post /users/{userId}/posts       특정 사용자에게 새로운 게시물 생성

모든 API의 응답 형식도 일관되게 설계해야 한다.
예를들어, 성공 시 HTTP상태코드와 JSON형식의 응답을 동일하게 유지하는게 좋다.

레이어시스템
클라이언트가 서버에 요청을 날릴 때, 여러 개의 레이어로된 서버를 거칠 수 있다.
클라이언트는 여러 레이어를 인지하지 않고, 최종적으로 서버에서 오는 응답만 신경쓰면 된다.
서버 측에서는 각 레이어가 독립적으로 동작하며, 각각의 레이어가 맡은 역할을 수행해 확장성, 보안성, 성능 최적화가 가능하다.

Controller
클라이언트로부터 요청을 받아오거나, 서버로부터 응답을 내보내는 역할

@RestController
html같은 뷰 페이지를 반환하는 대신, JSON이나 XML형식의 데이터를 반환하는 RESTful API를 제공하는데 적합하다.





























