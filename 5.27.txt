AsyncStorage
앱 내에 데이터를 로컬에 영구적으로 저장할 수 있도록 해주는 비동기 저장소 시스템

리액트할 때 로그인하면 토큰을 반환받고 localstorage에 저장을 했다.

AsyncStorage는 비동기로 작동을 하고 JSON기반으로 key-value형태로 데이터를 저장한다.
사용자가 로그인한 상태를 유지하고 싶을 때 사용한다
최근 검색어, 설정값, 토글 상태등을 기억하고 싶을 때

value에 넣을 때 JSON.stringify로 변환해서 저장한다.
setItem(key,value)로 저장하면 된다.

저장된 데이터를 확인하는법
const data = awiat AsyncStorage.getItem(key)

저장된 전체 key불러오기
const keys = awiat AsyncStorage.getAllKeys();

REACT-NATIVE-HOOKS참조
화살표함수로 호출하는 이유
1. 즉시 호출 방지
컴포넌트가 렌더링될 때 setCount(count+1)이 즉시 실행되어 onPress이벤트가 발생할 때가 아닌
렌더링 시점에 setCount가 호출된다.

2. this바인딩 문제 해결
리액트 클래스 컴포넌트에선 일반적으로 이벤트 헨들러에 this가 현재 컴포넌트를 참조하도록 사용했어야 했다.

useState의 상태 저장및 변경
상태는 컴포넌트가 재렌더링될 때 유지가된다.
상태변경함수를 사용하면 컴포넌트가 자동으로 재렌더링된다.

상태변경함수는 비동기적으로 동작한다.
변경 직후의 state값을 바로 읽으면, 여전히 이전값일 수 있다.
상태변경함수는 즉시 상태를 변경하는것이 아니라, React가 다음 렌더링 타이밍에 상태를 변경하고 컴포넌트를 다시 렌더링한다.

React는 성능 최적화를 위해 여러개의 setCount(count+1)가 호출될 때 하나의 렌더링 사이클로 묶어서 처리한다.
일괄 업데이트(batch update)라고 한다.

이전 상태값이 필요한 경우 반드시 함수형 업데이트를 사용해야한다.

useRef
특정 DOM요소나 값의 변화를 추적하거나 유지할 때 사용되는 객체를 반환해주는 역할
DOM요소에 접근하기 위해 사용하거나, 재렌더링 없이 상태를 유지할 때 사용하는 경우가 많다.

useMemo
메모이제이션을 통해 특정 연산의 결과를 저장해두고, 불필요한 반복 계산을 피하도록 도와준다.
이 훅은 복잡한 계산이 매번 다시 이루어지지않도록 최적화하는 역할을 하며,
의존성 배열에 따라 값이 바뀔때만 연산이 다시 수행되도록 설정할 수 있다.

메모이제이션이란 같은 계산을 반복해야 할 때 그 결과를 저장해두고 다시 필요할 때 저장된 값을 꺼내 사용하는 기법이다.

반복적으로 동일한 연산을 수행하지 않아도되어, 성능이 크게 향상된다.
useMemo가 이 메모이제이션을 사용할 수 있도록 지원하는 훅이다.

동작방식
useMemo는 특정 계산의 결과를 기억하고 있다가, 다음에 해당 계산이 필요할 때 의존하는 값이 바뀌지 않으면 이전 결과를 그대로 반환한다.

useMemo(() => {},[])

첫번째 인자(값을 계산하는 로직)
결과적으로 return값이 memoizedValue에 저장된다.
계산비용이 크거나 복잡한 로직을 여기에 작성한다.

두번째 인자는 의존성배열
이 배열안의 값중 하나라도 변경되면, 첫번째 함수가 실행된다.
이 배열이 변하지않으면 이전에 계산된 값을 재사용한다.

의존성배열을 비워두면 마운트시 한번 계산하고 끝이나기때문에 오류 발생 가능성이 있다.
반드시 의존하는 값은 두번째 인자에 포함시켜야 한다.

커스텀 hook만들기
내가 만들 hook함수는 API에 GET요청을 보내고 응답을 받는 함수이다.
리액트 네이티브에서는 네트워크 통신을 위해 fetch, axios를 제공하고 추가적으로 WebSocket도 지원한다.

이번에는 fetch를 이용해서 useFetch라는 이름의 hook을 만들어보자


























