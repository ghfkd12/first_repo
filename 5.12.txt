직렬화
자바 객체를 JSON문자열로 변환하는 과정
네트워크 전송, 파일 저장 등 바이트 스트림이나 텍스트 형태로 객체를 외부로 내보낼 때 사용
@RequestBody

역직렬화
JSON문자열을 자바객체로 변환하는 과정
외부에서 전달받은 JSON데이터를 자바객체로 복원할 때 사용
@RequestBody

PUT,DELETE는 POST와 같은 방식이다.

클라이언트와 서버간의 데이터를 주고받을 때는 DTO에 넣는다

서버에서 JPA에 데이터를 전달할 때만큼은 Entity여야 한다.
ㄴ DTO -> Entity로 변경하는 시점은 Controller나 Service 어느곳에서 해도 상관없다.

Entity : 테이블과 1:1로 매핑되는 클래스
엔티티의 필드는 테이블의 열과 일치해야한다.

엔티티로 데이터를 주고받게되면 혹여나 내 데이터베이스 스키마가 노출될 수 있다.
예민한 정보들을 빼고 전달할 수 있는 DTO클래스를 만들어서 주고받는다.

DTO(Data Transfer Object)

HTTP의 특성
무상태성(stateless)
서버가 클라이언트의 이전 요청 상태를 보존하지 않는 특성을 말한다.

요청에 필요한 모든 정보(인증 정보, 파라미터)는 매번 포함되어야 하며, 서버는 별도로 세션상태를 조회하지 않는다.

무상태성을 보완하기 위한 기법
1. 쿠키(Cookie)
- 서
- 이후 요청시 쿠키가 헤더에 담겨서 넘어온다.

2. 세션(Session)
- 서버가 메모리나 데이터베이스에 세션정보를 저장
- 클라이언트에게 세션 ID만 전달한다.
- 클라이언트는 매 요청시 세션 ID를 보내고, 서버는 ID로 세션상태를 조회하여 연속성을 유지한다.

3. 토큰기반인증(Token-Based Auth)
- JWT같은 토큰을 발급해 클라이언트에 저장하게한다.
- 클라이언트는 Authorization : Bearer '토큰값' 헤더에 토큰을 감아 요청하며, 서버는 토큰을 검증해 사용자 정보를 얻는다.

아이디와 비밀번호를 통해서 인증이 완료되면 토큰을 발급해 준다.
회원가입할 때가아니라 로그인할 때 토큰을 발급해준다.

1. 사용자가 우리의 todo기능을 사용하려고 할 때 토큰을 요청에 같이 실어서 보낸다.

2. 기능이 실행되기 전에 토큰이 유효한지 검증해야 한다.
ㄴ 기능마다 검증하는 코드를 만들어도 상관없다.
ㄴ 기능이 50개 100개가 넘어가면 직접 만드는 것은 비효율적이다.

3. 필터
클라이언트의 요청이 컨트롤러에 도달하기 전 또는 응답으로 나가기 전에 가로채서 추가 작업을 수행하는것이다.
ㄴ 두 군데에서 가능하다는 것이지 무조건 두 군데에서 해야하는것은 아니다.

커스텀 필터를 제작
Filter클래스
여러번 실행될 수 있다.
init(), doFilter(), destory() 메서드가 존재한다.

OncPerRequestFilter클래스
스프링이 제공하는 추상클래스
같은 요청에 대해서 한번만 실행되도록 보장한다.
내부적으로 이미 실행된 요청인지 판단해서 중복 실행을 막는다.

doFilterInternal()메서드만 구현하면 된다.

CSRF
사용자가 이미 로그인한 웹사이트(A)의 세션 쿠키를 가진 상태에서,
공격자가 만든 악성페이지를 열도록 유도하면,
B페이지에서 A서버로 사용자 권한으로 위조된 요청을 보낼 수 있다.

disabled() : REST API처럼 세션을 사용하지 않거나, 클라이언트가 토큰을 처리하기 어려운 경우 보호 기능을 끌 수 있다.
토큰을 처리하기 어려운 경우 보호 기능을 끌 수 있다.

프론트엔드 통합
프론트엔드 어플리케이션은 이제부터 백엔드 HTTP요청을 보낼 때 403이 날라오면 토큰을 어딘가에 저장해놓고
로그인 페이지로 리다이렉트 해야한다.
저장해놓은 토큰을 HTTP요청을 보낼 때마다 헤더에 Bearer토큰으로 지정해야 한다.






















